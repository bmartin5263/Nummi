using System.Text.Json.Serialization;
using KSUID;
using Microsoft.EntityFrameworkCore;
using NLog;
using Nummi.Core.Util;

namespace Nummi.Core.Domain.Crypto.Strategies; 

[PrimaryKey("Id")]
[JsonConverter(typeof(Serializer.AbstractTypeConverter<Strategy>))]
public abstract class Strategy {
    
    private static readonly Logger Log = LogManager.GetCurrentClassLogger();

    // Unique id for this strategy
    public string Id { get; } = Ksuid.Generate().ToString();
    
    // How often should this strategy check for possible trades
    public TimeSpan Frequency { get; }
    
    // Has this strategy been initialized?
    public bool Initialized { get; private set; }
    
    // Profit generated by this Strategy, may be negative :(
    public decimal Profit { get; private set; }
    
    // How many times this trading strategy checked for trades
    public uint TimesExecuted { get; private set; }
    
    // When was the last time this strategy ran?
    public DateTime? LastExecutedAt { get; private set; }
    
    // How many times this trading strategy threw an exception
    public uint TimesFailed { get; private set; }
    
    // The current error state. Includes info on what error occurred and when
    public StrategyError? ErrorState { get; private set; }
    
    // Historical errors
    public StrategyErrorHistory? ErrorHistory { get; private set; }
    
    protected Strategy(TimeSpan frequency) {
        Frequency = frequency;
    }
    
    private void Initialize(TradingContext env) {
        try {
            DoInitialize(env);
        }
        catch (Exception e) {
            throw new StrategyException($"PrepareForTrading() failed for user TradingStrategy {Id}", e);
        }
        Initialized = true;
    }

    public Result CheckForTrades(TradingContext env) {
        if (ErrorState != null) {
            Log.Info("ErrorState is not null, cannot run strategy while in error state");
            return new Result();
        }
        if (!Initialized) {
            Initialize(env);
        }
        try {
            ++TimesExecuted;
            LastExecutedAt = DateTime.Now;
            var result = DoCheckForTrades(env);
            env.AppDb.Attach(this);
            env.AppDb.Update(this);
            return result;
        }
        catch (Exception e) {
            ++TimesFailed;
            PushErrorState(new StrategyError(DateTime.Now, e.ToString()));
            throw new StrategyException($"ExecuteTrades() failed for user TradingStrategy {Id}", e);
        }
    }
    
    public void AddProfit(decimal amount) {
        Profit += amount;
    }

    private void PushErrorState(StrategyError error) {
        if (ErrorState != null) {
            ClearErrorState();
        }
        ErrorState = error;
    }

    public void ClearErrorState() {
        if (ErrorState == null) {
            throw new ArgumentException("No error state to clear");
        }
        ErrorHistory ??= new StrategyErrorHistory();
        ErrorHistory.Add(ErrorState);
        ErrorState = null;
    }

    protected abstract void DoInitialize(TradingContext env);
    protected abstract Result DoCheckForTrades(TradingContext env);

    public virtual IDictionary<string, object?>? GetStateMap() => null;

}