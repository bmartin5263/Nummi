using System.ComponentModel.DataAnnotations.Schema;
using System.Text.Json.Serialization;
using KSUID;
using Microsoft.EntityFrameworkCore;
using Nummi.Core.Domain.Crypto.Bot;
using Nummi.Core.Util;

namespace Nummi.Core.Domain.Crypto.Trading.Strategy; 

[Table("Strategy")]
[PrimaryKey("Id")]
[JsonConverter(typeof(Serializer.AbstractTypeConverter<TradingStrategy>))]
public abstract class TradingStrategy {
    
    // Unique id for this strategy
    public Ksuid Id { get; } = Ksuid.Generate();
    
    // How often should this strategy check for possible trades
    public TimeSpan Frequency { get; }
    
    // Has this strategy been initialized?
    public bool Initialized { get; private set; }
    
    // Profit generated by this Strategy, may be negative :(
    public decimal Profit { get; private set; }
    
    // How many times this trading strategy checked for trades
    public uint TimesExecuted { get; private set; }
    
    // When was the last time this strategy ran?
    public DateTime? LastExecutedAt { get; private set; }
    
    // How many times this trading strategy threw an exception
    public uint TimesFailed { get; private set; }
    
    // The current error state. Includes info on what error occurred and when
    public BotError? ErrorState { get; private set; }
    
    // Historical errors
    public BotErrorHistory? ErrorHistory { get; private set; }
    
    protected TradingStrategy(TimeSpan frequency) {
        Frequency = frequency;
    }
    
    private void Initialize(TradingContext env) {
        try {
            DoInitialize(env);
        }
        catch (Exception e) {
            throw new StrategyException($"PrepareForTrading() failed for user TradingStrategy {Id}", e);
        }
        Initialized = true;
    }

    public Result CheckForTrades(TradingContext env) {
        if (!Initialized) {
            Initialize(env);
        }
        try {
            ++TimesExecuted;
            LastExecutedAt = DateTime.Now;
            return DoCheckForTrades(env);
        }
        catch (Exception e) {
            ++TimesFailed;
            ErrorState = new BotError(DateTime.Now, e.ToString());
            throw new StrategyException($"ExecuteTrades() failed for user TradingStrategy {Id}", e);
        }
    }
    
    public void AddProfit(decimal amount) {
        Profit += amount;
    }

    public void ClearErrorState() {
        if (ErrorState == null) {
            throw new ArgumentException("No error state to clear");
        }
        ErrorHistory ??= new BotErrorHistory();
        ErrorHistory.Add(ErrorState);
        ErrorState = null;
    }

    protected abstract void DoInitialize(TradingContext env);
    protected abstract Result DoCheckForTrades(TradingContext env);

    public virtual IDictionary<string, object?>? GetStateMap() => null;

}